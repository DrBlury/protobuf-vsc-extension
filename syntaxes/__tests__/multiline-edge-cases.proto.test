// SYNTAX TEST "source.proto" "Multi-line and whitespace edge cases per protobuf spec"

syntax = "proto3";
// <-- keyword.control.syntax.proto

package edgecases;
// <--- keyword.control.package.proto


// =============================================================================
// EDGE CASE 1: Message with brace on next line
// =============================================================================
message BraceOnNextLine
// <--- keyword.declaration.message.proto
//      ^^^^^^^^^^^^^^^ entity.name.type.message.proto
{
    int32 id = 1;
//  ^^^^^ storage.type.proto
//        ^^ variable.other.field.proto
}


// =============================================================================
// EDGE CASE 2: Field number on separate line (from test_message.proto)
// =============================================================================
message MultiLineFieldNumber {
    float value =
//  ^^^^^ storage.type.proto
//        ^^^^^ variable.other.field.proto
//              ^ keyword.operator.assignment.proto
            1;
//          ^ constant.numeric.proto
//           ^ punctuation.terminator.proto
    bool valid =
//  ^^^^ storage.type.proto
//       ^^^^^ variable.other.field.proto
            2;
//          ^ constant.numeric.proto
}


// =============================================================================
// EDGE CASE 3: Field number on separate line with comment between
// =============================================================================
message FieldNumberWithComment {
    string name = // inline comment before number
//  ^^^^^^ storage.type.proto
//         ^^^^ variable.other.field.proto
//              ^ keyword.operator.assignment.proto
//                ^^ comment.line.double-slash.proto
        1;
//      ^ constant.numeric.proto
    int32 count = /* block comment */
//  ^^^^^ storage.type.proto
        2;
//      ^ constant.numeric.proto
}


// =============================================================================
// EDGE CASE 4: Modifier with field number on separate line
// =============================================================================
message ModifierMultiLine {
    optional string opt_field =
//  ^^^^^^^^ keyword.other.modifier.proto
//           ^^^^^^ storage.type.proto
//                  ^^^^^^^^^ variable.other.field.proto
        1;
//      ^ constant.numeric.proto
    repeated int32 rep_field =
//  ^^^^^^^^ keyword.other.modifier.proto
//           ^^^^^ storage.type.proto
//                 ^^^^^^^^^ variable.other.field.proto
        2;
//      ^ constant.numeric.proto
}


// =============================================================================
// EDGE CASE 5: Field with lots of whitespace on same logical line
// Note: Extreme case where type is alone on a line is valid protobuf but
// impractical to support in TextMate grammar. We support the common patterns.
// =============================================================================
message ReasonableWhitespace {
    string    field_name    =    1    ;
//  ^^^^^^ storage.type.proto
//            ^^^^^^^^^^ variable.other.field.proto
//                          ^ keyword.operator.assignment.proto
//                               ^ constant.numeric.proto
//                                    ^ punctuation.terminator.proto
}


// =============================================================================
// EDGE CASE 6: Field with options spanning multiple lines
// =============================================================================
message MultiLineOptions {
    string name = 1 [deprecated = true];
//  ^^^^^^ storage.type.proto
//         ^^^^ variable.other.field.proto
//              ^ keyword.operator.assignment.proto
//                ^ constant.numeric.proto
//                  ^ punctuation.definition.brackets.begin.proto
//                   ^^^^^^^^^^ support.other.option.proto
//                              ^ keyword.operator.assignment.proto
//                                ^^^^ constant.language.proto
//                                    ^ punctuation.definition.brackets.end.proto
}


// =============================================================================
// EDGE CASE 7: Enum with brace on next line
// =============================================================================
enum StatusEnum
// <-keyword.declaration.enum.proto
//   ^^^^^^^^^^ entity.name.type.enum.proto
{
    STATUS_UNSPECIFIED = 0;
//  ^^^^^^^^^^^^^^^^^^ variable.other.enummember.proto
    STATUS_ACTIVE = 1;
//  ^^^^^^^^^^^^^ variable.other.enummember.proto
}


// =============================================================================
// EDGE CASE 8: Service with brace on next line
// =============================================================================
service MyService
// <--- keyword.declaration.service.proto
//      ^^^^^^^^^ entity.name.type.service.proto
{
    rpc GetItem(GetRequest) returns (GetResponse);
//  ^^^ keyword.declaration.rpc.proto
//      ^^^^^^^ entity.name.function.rpc.proto
}


// =============================================================================
// EDGE CASE 9: Multiple blank lines between everything
// =============================================================================


message AfterBlanks {
// <--- keyword.declaration.message.proto


    int32 field1 = 1;
//  ^^^^^ storage.type.proto


    string field2 = 2;
//  ^^^^^^ storage.type.proto


}


// =============================================================================
// EDGE CASE 10: Nested message with brace on next line
// =============================================================================
message OuterMessage {
    message InnerMessage
//  ^^^^^^^ keyword.declaration.message.proto
//          ^^^^^^^^^^^^ entity.name.type.message.proto
    {
        int32 inner_id = 1;
//      ^^^^^ storage.type.proto
    }

    InnerMessage inner = 1;
//  ^^^^^^^^^^^^ entity.name.type.proto
//               ^^^^^ variable.other.field.proto
}


// =============================================================================
// EDGE CASE 11: Oneof with brace on next line
// =============================================================================
message OneofTest {
    oneof test_oneof
//  ^^^^^ keyword.declaration.oneof.proto
//        ^^^^^^^^^^ variable.other.oneof.proto
    {
        string name = 1;
//      ^^^^^^ storage.type.proto
        int32 id = 2;
//      ^^^^^ storage.type.proto
    }
}


// =============================================================================
// EDGE CASE 12: Custom type with multi-line field number
// =============================================================================
message CustomTypeMultiLine {
    OuterMessage.InnerMessage nested =
//  ^^^^^^^^^^^^^^^^^^^^^^^^^ entity.name.type.proto
//                            ^^^^^^ variable.other.field.proto
        1;
//      ^ constant.numeric.proto
}


// =============================================================================
// EDGE CASE 13: Map with various whitespace (single line required by spec)
// =============================================================================
message MapTest {
    map<string, int32> data = 1;
//  ^^^ keyword.other.map.proto
//      ^^^^^^ storage.type.proto
//              ^^^^^ storage.type.proto
//                     ^^^^ variable.other.field.proto
//                            ^ constant.numeric.proto
}


// =============================================================================
// EDGE CASE 14: Mixed constructs with aggressive whitespace
// =============================================================================




message FirstConstruct {
// <--- keyword.declaration.message.proto
    int32 a = 1;
//  ^^^^^ storage.type.proto
}




enum SecondConstruct {
// <-keyword.declaration.enum.proto
    VALUE = 0;
}




message ThirdConstruct {
// <--- keyword.declaration.message.proto
    string b = 1;
//  ^^^^^^ storage.type.proto
}




service FourthConstruct {
// <--- keyword.declaration.service.proto
    rpc Method(FirstConstruct) returns (ThirdConstruct);
//  ^^^ keyword.declaration.rpc.proto
}




message FifthConstruct {
// <--- keyword.declaration.message.proto
    bool c = 1;
//  ^^^^ storage.type.proto
}


// =============================================================================
// EDGE CASE 15: Hex field numbers on separate lines
// =============================================================================
message HexFieldNumbers {
    int32 hex_field =
//  ^^^^^ storage.type.proto
        0x10;
//      ^^^^ constant.numeric.proto
}


// =============================================================================
// EDGE CASE 16: RPC definitions with various formatting
// =============================================================================
message GetRequest {}
message GetResponse {}
message ListRequest {}
message ListResponse {}

service FormattingService {
    // Standard single line
    rpc Get(GetRequest) returns (GetResponse);
//  ^^^ keyword.declaration.rpc.proto
//      ^^^ entity.name.function.rpc.proto
//          ^^^^^^^^^^ entity.name.type.proto
//                      ^^^^^^^ keyword.control.returns.proto
//                               ^^^^^^^^^^^ entity.name.type.proto

    // With streaming
    rpc List(ListRequest) returns (stream ListResponse);
//  ^^^ keyword.declaration.rpc.proto
//      ^^^^ entity.name.function.rpc.proto
//                                 ^^^^^^ keyword.other.stream.proto
//                                        ^^^^^^^^^^^^ entity.name.type.proto
}
