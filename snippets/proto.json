{
  "proto3 syntax": {
    "prefix": "syntax3",
    "body": [
      "syntax = \"proto3\";",
      "",
      "package ${1:package_name};",
      "",
      "$0"
    ],
    "description": "Proto3 syntax declaration with package"
  },
  "proto2 syntax": {
    "prefix": "syntax2",
    "body": [
      "syntax = \"proto2\";",
      "",
      "package ${1:package_name};",
      "",
      "$0"
    ],
    "description": "Proto2 syntax declaration with package"
  },
  "edition 2023": {
    "prefix": "edition2023",
    "body": ["edition = \"2023\";", "", "package ${1:package_name};", "", "$0"],
    "description": "Edition 2023 declaration with package"
  },
  "message": {
    "prefix": "message",
    "body": ["message ${1:MessageName} {", "  $0", "}"],
    "description": "Message declaration"
  },
  "enum": {
    "prefix": "enum",
    "body": ["enum ${1:EnumName} {", "  ${2:UNKNOWN} = 0;", "  $0", "}"],
    "description": "Enum declaration"
  },
  "service": {
    "prefix": "service",
    "body": ["service ${1:ServiceName} {", "  $0", "}"],
    "description": "Service declaration"
  },
  "rpc": {
    "prefix": "rpc",
    "body": ["rpc ${1:MethodName}(${2:Request}) returns (${3:Response});"],
    "description": "RPC method declaration"
  },
  "rpc with body": {
    "prefix": "rpcbody",
    "body": [
      "rpc ${1:MethodName}(${2:Request}) returns (${3:Response}) {",
      "  $0",
      "}"
    ],
    "description": "RPC method declaration with body for options"
  },
  "rpc stream": {
    "prefix": "rpcstream",
    "body": [
      "rpc ${1:MethodName}(stream ${2:Request}) returns (stream ${3:Response});"
    ],
    "description": "Bidirectional streaming RPC"
  },
  "oneof": {
    "prefix": "oneof",
    "body": ["oneof ${1:name} {", "  $0", "}"],
    "description": "Oneof declaration"
  },
  "import": {
    "prefix": "import",
    "body": ["import \"${1:path}\";"],
    "description": "Import statement"
  },
  "import public": {
    "prefix": "importpublic",
    "body": ["import public \"${1:path}\";"],
    "description": "Public import statement"
  },
  "package": {
    "prefix": "package",
    "body": ["package ${1:name};"],
    "description": "Package declaration"
  },
  "extend": {
    "prefix": "extend",
    "body": ["extend ${1:MessageName} {", "  $0", "}"],
    "description": "Extend declaration"
  },
  "option": {
    "prefix": "option",
    "body": ["option ${1:name} = ${2:value};"],
    "description": "Option declaration"
  },
  "field string": {
    "prefix": "fstring",
    "body": ["string ${1:field_name} = ${2:1};"],
    "description": "String field"
  },
  "field int32": {
    "prefix": "fint32",
    "body": ["int32 ${1:field_name} = ${2:1};"],
    "description": "Int32 field"
  },
  "field int64": {
    "prefix": "fint64",
    "body": ["int64 ${1:field_name} = ${2:1};"],
    "description": "Int64 field"
  },
  "field bool": {
    "prefix": "fbool",
    "body": ["bool ${1:field_name} = ${2:1};"],
    "description": "Bool field"
  },
  "field bytes": {
    "prefix": "fbytes",
    "body": ["bytes ${1:field_name} = ${2:1};"],
    "description": "Bytes field"
  },
  "field double": {
    "prefix": "fdouble",
    "body": ["double ${1:field_name} = ${2:1};"],
    "description": "Double field"
  },
  "field float": {
    "prefix": "ffloat",
    "body": ["float ${1:field_name} = ${2:1};"],
    "description": "Float field"
  },
  "field repeated": {
    "prefix": "frepeated",
    "body": ["repeated ${1:type} ${2:field_name} = ${3:1};"],
    "description": "Repeated field"
  },
  "field map": {
    "prefix": "fmap",
    "body": ["map<${1:key_type}, ${2:value_type}> ${3:field_name} = ${4:1};"],
    "description": "Map field"
  },
  "reserved numbers": {
    "prefix": "reservedn",
    "body": ["reserved ${1:2}, ${2:15}, ${3:9} to ${4:11};"],
    "description": "Reserved field numbers"
  },
  "reserved names": {
    "prefix": "reserveds",
    "body": ["reserved \"${1:field_name}\";"],
    "description": "Reserved field names"
  },
  "option go_package": {
    "prefix": "optgopackage",
    "body": ["option go_package = \"${1:path}\";"],
    "description": "Go package option"
  },
  "option java_package": {
    "prefix": "optjavapackage",
    "body": ["option java_package = \"${1:com.example}\";"],
    "description": "Java package option"
  },
  "option java_outer_classname": {
    "prefix": "optjavaclass",
    "body": ["option java_outer_classname = \"${1:ClassName}\";"],
    "description": "Java outer classname option"
  },
  "option deprecated": {
    "prefix": "optdeprecated",
    "body": ["[deprecated = true]"],
    "description": "Deprecated field option"
  },
  "buf.validate.message cel": {
    "prefix": "celvalidate",
    "body": [
      "option (buf.validate.message).cel = {",
      "\tid: \"${1:validation_id}\",",
      "\tmessage: \"${2:Validation failed}\",",
      "\texpression:",
      "\t\"${3:!has(this.field)}\"",
      "\t\"? '${4:Field is required}'\"",
      "\t\": ''\"",
      "};"
    ],
    "description": "Buf CEL message validation option"
  },
  "buf.validate.message cel either-or": {
    "prefix": "celeither",
    "body": [
      "option (buf.validate.message).cel = {",
      "\tid: \"${1:either_field1_or_field2}\",",
      "\tmessage: \"${2:Either field1 or field2 must be set}\",",
      "\texpression:",
      "\t\"!(has(this.${3:field1}) || has(this.${4:field2}))\"",
      "\t\"? 'Either ${3:field1} or ${4:field2} must be set'\"",
      "\t\": ''\"",
      "};"
    ],
    "description": "Buf CEL either/or validation (one of two fields required)"
  },
  "buf.validate.message cel mutually exclusive": {
    "prefix": "celmutex",
    "body": [
      "option (buf.validate.message).cel = {",
      "\tid: \"${1:only_one_field}\",",
      "\tmessage: \"${2:Only one field can be set, not both}\",",
      "\texpression:",
      "\t\"has(this.${3:field1}) && has(this.${4:field2})\"",
      "\t\"? 'Only one of ${3:field1} or ${4:field2} can be set, not both'\"",
      "\t\": ''\"",
      "};"
    ],
    "description": "Buf CEL mutually exclusive validation (at most one field)"
  },
  "buf.validate.message cel size check": {
    "prefix": "celsize",
    "body": [
      "option (buf.validate.message).cel = {",
      "\tid: \"${1:field_size_check}\",",
      "\tmessage: \"${2:Field must have required size}\",",
      "\texpression:",
      "\t\"!(size(this.${3:field}) == ${4:2})\"",
      "\t\"? '${3:field} must be ${4:2} characters long'\"",
      "\t\": ''\"",
      "};"
    ],
    "description": "Buf CEL size validation for repeated fields or strings"
  },
  "buf.validate.message cel conditional": {
    "prefix": "celif",
    "body": [
      "option (buf.validate.message).cel = {",
      "\tid: \"${1:conditional_validation}\",",
      "\tmessage: \"${2:If field1 is set, field2 must also be set}\",",
      "\texpression:",
      "\t\"has(this.${3:field1}) != has(this.${4:field2})\"",
      "\t\"? 'Both ${3:field1} and ${4:field2} must be set together'\"",
      "\t\": ''\"",
      "};"
    ],
    "description": "Buf CEL conditional validation (both fields must be set together)"
  },
  "buf.validate.field cel": {
    "prefix": "celfieldvalidate",
    "body": [
      "${1:type} ${2:field_name} = ${3:1} [(buf.validate.field).cel = {",
      "\tid: \"${4:field_validation}\",",
      "\tmessage: \"${5:Field validation failed}\",",
      "\texpression:",
      "\t\"!(${6:this > 0})\"",
      "\t\"? '${7:Value must be positive}'\"",
      "\t\": ''\"",
      "}];"
    ],
    "description": "Buf CEL field-level validation option (inline on field)"
  },
  "buf.validate.field cel string pattern": {
    "prefix": "celpattern",
    "body": [
      "string ${1:field_name} = ${2:1} [(buf.validate.field).cel = {",
      "\tid: \"${3:string_pattern}\",",
      "\tmessage: \"${4:String must match pattern}\",",
      "\texpression:",
      "\t\"!this.matches('${5:^[a-z]+$}')\"",
      "\t\"? 'Value must match pattern ${5:^[a-z]+$}'\"",
      "\t\": ''\"",
      "}];"
    ],
    "description": "Buf CEL string pattern validation (inline on field)"
  },
  "buf.validate.field cel range": {
    "prefix": "celrange",
    "body": [
      "${1:int32} ${2:field_name} = ${3:1} [(buf.validate.field).cel = {",
      "\tid: \"${4:number_range}\",",
      "\tmessage: \"${5:Number must be in range}\",",
      "\texpression:",
      "\t\"!(this >= ${6:0} && this <= ${7:100})\"",
      "\t\"? 'Value must be between ${6:0} and ${7:100}'\"",
      "\t\": ''\"",
      "}];"
    ],
    "description": "Buf CEL numeric range validation (inline on field)"
  }
}
